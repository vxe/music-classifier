# -*- mode:org -*-
#+TITLE: music classifier
#+STARTUP: indent
#+OPTIONS: toc:nil

#+BEGIN_SRC clojure :tangle data.clj
    (ns music-classifier.data
      (:require [clj-http.client]
                [clojure.data.codec.base64 :as b64]
                [clojure.contrib.sql :as sql]
                [music-classifier.auth :refer :all])
      (:use [com.rpl.specter]
            [clojure.java.shell :only [sh]]))
#+END_SRC
* utilities
* constants
** pitch class to key mapping
 #+BEGIN_SRC clojure :tangle data.clj
 (def pitch-classes [:c :c# :d :d# :e :f :f# :g :g# :a :a# :b])
 #+END_SRC
** key to pitch class mapping
 #+BEGIN_SRC clojure :tangle data.clj
 (def pitch-keys {:c 0 :c# 1 :d 2 :d# 3 :e 4 :f 5 :f# 6 :g 7 :g# 8 :a 9 :a# 10 :b 11})
 #+END_SRC
* components
* experimental
** audio features for all tracks in currents user's library
#+BEGIN_SRC clojure :tangle data.clj
  (def analyzed-tracks (agent {}))

  (defn get-audio-features-by-track-id [id]
    (cheshire.core/parse-string
     (:out
      (sh "curl"
          "-s"
          "-H"
          @D_access-token--atm
          (str "https://api.spotify.com/v1/audio-features/" id))) true))

  (defn analyze-library []
    (pmap (fn [id]
            (if (or (:error ((keyword id) @analyzed-tracks))
                    (= nil ((keyword id) @analyzed-tracks)))
              (do
                (prn id " is nil")
                (future (send analyzed-tracks assoc (keyword id) (get-audio-features-by-track-id id))))))
          (select [ALL :id] (io_get-all-library-track-names--web))))

#+END_SRC
*** TODO song to artist mapping
** debug
#+BEGIN_SRC clojure :tangle data.clj
   (defn debug:print-nil-tracks []
     (clojure.pprint/pprint (select [ALL ALL #(= nil (:valence %))]  @analyzed-tracks)))


   (defn debug:find-nil-tracks []
     (select [ALL ALL #(= nil (:valence %))]  @analyzed-tracks))


#+END_SRC

** _library-maintenance subsystem
*** reference types
**** atoms (D_...--atm)
**** agents (D_...--agt)
**** refs (D_...--ref)
*** IO
**** web (io_...--web)
**** database (io_...--db)
#+BEGIN_SRC clojure
io_
#+END_SRC
**** filesystem (io_...--fs)
*** compute
#+BEGIN_SRC clojure
    
#+END_SRC    
** _track-search subsystem
*** reference types
**** atoms (D_...--atm)
***** id-to-name mapping
    #+BEGIN_SRC clojure :tangle data.clj
      (def track-id-name-map (atom {}))

      (defn build-track-id-map []
        (for [track (io_get-all-library-track-names--web)]
          (cond (= nil (:id track)) (prn (str  "id " (:id track) " is missing" ))
                (= nil (:name track)) (prn (str "track name " (:name track) " is missing"))
                :else
                (swap! track-id-name-map assoc (keyword (:id track))  (:name track)))))

    #+END_SRC

**** agents (D_...--agt)
**** refs (D_...--ref)
*** IO
**** web (io_...--web)
***** audio-analysis
***** /audio-features
***** /tracks
      #+BEGIN_SRC clojure :tangle data.clj
        (defn io_hit-tracks-endpoint--web [ids]
          (second
           (second
            (try 
              (cheshire.core/parse-string
               (:out
                (sh "curl"
                    "-s"
                    "-H"
                    (str "Authorization: Bearer " @D_access-token--atm)
                    (str "https://api.spotify.com/v1/me/tracks?limit=10"))) true)
                  (catch Exception e
              (do (D_refresh-access-token!)
                  (cheshire.core/parse-string
                   (:out
                    (sh "curl"
                        "-s"
                        "-H"
                        @D_access-token--atm
                        (str "https://api.spotify.com/v1/me/tracks?limit=10"))) true)))))))
      #+END_SRC
***** all tracks
 #+BEGIN_SRC clojure :tangle data.clj
   (defn io_get-all-library-track-names--web []
     (flatten
      (distinct
       (select [ALL :track]
                 (second
                  (second
                   (cheshire.core/parse-string
                    (:out
                     (sh "curl"
                         "-s"
                         "-H"
                         @D_access-token--atm
                         (str "https://api.spotify.com/v1/me/tracks?limit=10"))) true)))))))
 #+END_SRC
***** all track id_s?
 #+BEGIN_SRC clojure :tangle data.clj
   (defn io_get-all-library-track-ids--web []
     (flatten
      (distinct
       (select [ALL :track :id]
                 (second
                  (second
                   (cheshire.core/parse-string
                    (:out
                     (sh "curl"
                         "-s"
                         "-H"
                         @D_access-token--atm
                         (str "https://api.spotify.com/v1/me/tracks?limit=50"))) true))))
   )))
 #+END_SRC
***** all track names
 #+BEGIN_SRC clojure :tangle data.clj
   (defn io_get-all-library-track-names--web []
     (flatten
      (distinct
       (select [ALL :track :name]
                 (second
                  (second
                   (cheshire.core/parse-string
                    (:out
                     (sh "curl"
                         "-s"
                         "-H"
                         @D_access-token--atm
                         (str "https://api.spotify.com/v1/me/tracks?limit=50"))) true)))))))
 #+END_SRC
**** database (io_...--db)
***** update database for new tracks
**** filesystem (io_...--fs)
*** compute
**** track name by id
 #+BEGIN_SRC clojure :tangle data.clj
    (defn lookup-track-name-by-id [id]
      (let [name ((keyword id) @track-id-name-map)]
        (if (= nil name)
          (prn id " is mising")
          name)))
 #+END_SRC
**** track id by name
 #+BEGIN_SRC clojure :tangle data.clj
    (defn lookup-track-id-by-name [name]
      (remove nil? (for [[k v] @track-id-name-map]
                     (if (= name v)
                       k))))
 #+END_SRC
**** track id by regex
 #+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-id-by-regex [regex]
     (remove nil? (for [[k v] @track-id-name-map]
                    (let [track-match (re-matches regex v)]
                      (if track-match
                        k
                        (build-track-id-map))))))
 #+END_SRC
**** get audio features by track name
    #+BEGIN_SRC clojure :tangle data.clj
        (defn lookup-audio-features-by-track-name [name]
      ((first (lookup-track-id-by-name name)) @analyzed-tracks))

    #+END_SRC
**** get audio features by regex
#+BEGIN_SRC clojure :tangle data.clj
  ;; (defn lookup-audio-features-by-track-regex [title]
  ;;   (let [track (lookup-track-id-by-regex title)]
  ;;     (cond (list? ((first track) @analyzed-tracks)) (prn track))
  ;;     :else
  ;;         ((first track) @analyzed-tracks)
  ;;     ))


      (defn lookup-audio-features-by-track-regex [title]
        ((first (lookup-track-id-by-regex title)) @analyzed-tracks))
#+END_SRC
**** track by feature and value
#+BEGIN_SRC 
   (defn lookup-track-by-feature [feature comparison value]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [(keyword feature)] v)) value)
                      (:id v)))))

#+END_SRC
**** track by valence 
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-valence [comparison valence]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:valence] v)) valence)
                      (:id v)
                      (prn k)
                      ))))

#+END_SRC
**** track by loudness
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-loudness [comparison loudness]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:loudness] v)) loudness)
                      (:id v)))))

#+END_SRC
**** track by musical key
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-key [comparison key]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:key] v)) key)
                      (:id v)))))

#+END_SRC
**** track by duration
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-duration [comparison duration]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:duration] v)) duration)
                      (:id v)))))

#+END_SRC
**** track by instrumentalness
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-instrumentalness [comparison instrumentalness]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:instrumentalness] v)) instrumentalness)
                      (:id v)))))

#+END_SRC
**** track by major or minor mode
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-mode [comparison mode]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:mode] v)) mode)
                      (:id v)))))

#+END_SRC
**** track by energy
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-energy [comparison energy]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:energy] v)) energy)
                      (:id v)))))

#+END_SRC
**** track by speechiness
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-speechiness [comparison speechiness]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:speechiness] v)) speechiness)
                      (:id v)))))

#+END_SRC
**** track by time signature
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-time_signature [comparison time_signature]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:time_signature] v)) time_signature)
                      (:id v)))))

#+END_SRC
**** track by liveness
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-liveness [comparison liveness]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:liveness] v)) liveness)
                      (:id v)))))

#+END_SRC
**** track by danceability
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-danceability [comparison danceability]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:danceability] v)) danceability)
                      (:id v)))))

#+END_SRC
**** track by tempo
#+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-tempo [comparison tempo]
     (remove nil? (for [[k v] @analyzed-tracks]
                    (if (comparison (first (select [:tempo] v)) tempo)
                      (:id v)))))

#+END_SRC
**** track by acousticness
 #+BEGIN_SRC clojure :tangle data.clj
   (defn lookup-track-by-acousticness [comparison acousticness]
     (remove nil? (for [[k v] @analyzed-tracks]
                   (if (comparison (first (select [:acousticness] v)) acousticness)
                     (:id v)))))




 #+END_SRC


** _playlist-extraction
*** reference types
**** atoms
#+BEGIN_SRC clojure :tangle data.clj
(def atm--all-tracks (atom []))
#+END_SRC
**** agents 
**** refs
*** IO
**** web (io_...--web)
#+BEGIN_SRC clojure :tangle data.clj
  (defn io-web--get-library-tracks
                          ([]
                           (clj-http.client/get "https://api.spotify.com/v1/me/tracks?limit=50" {:headers {"Authorization" (str "Bearer " @D_access-token--atm)}})

                           )
                          ([offset]
                           (clj-http.client/get (str "https://api.spotify.com/v1/me/tracks?limit=50&offset=" offset) {:headers {"Authorization" (str "Bearer " @D_access-token--atm)}})

                           )
    )

#+END_SRC
**** database (io_...--db)
**** filesystem (io_...--fs)
*** compute
#+BEGIN_SRC clojure
    
#+END_SRC    
